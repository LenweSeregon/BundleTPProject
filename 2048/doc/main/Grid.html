<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="fr">
<head>
<!-- Generated by javadoc (1.8.0_111) on Sun Jan 22 23:50:22 CET 2017 -->
<title>Grid</title>
<meta name="date" content="2017-01-22">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
<script type="text/javascript" src="../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Grid";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":10,"i41":10,"i42":10,"i43":10,"i44":10,"i45":10,"i46":10,"i47":10,"i48":10,"i49":10,"i50":10,"i51":10,"i52":10,"i53":10,"i54":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Grid.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../main/Direction.html" title="enum in main"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../main/IA_player.html" title="class in main"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../index.html?main/Grid.html" target="_top">Frames</a></li>
<li><a href="Grid.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.classes.inherited.from.class.javax.swing.JPanel">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">main</div>
<h2 title="Class Grid" class="title">Class Grid</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>java.awt.Component</li>
<li>
<ul class="inheritance">
<li>java.awt.Container</li>
<li>
<ul class="inheritance">
<li>javax.swing.JComponent</li>
<li>
<ul class="inheritance">
<li>javax.swing.JPanel</li>
<li>
<ul class="inheritance">
<li>main.Grid</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd>java.awt.image.ImageObserver, java.awt.MenuContainer, java.io.Serializable, javax.accessibility.Accessible</dd>
</dl>
<hr>
<br>
<pre>public class <span class="typeNameLabel">Grid</span>
extends javax.swing.JPanel</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../serialized-form.html#main.Grid">Serialized Form</a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<ul class="blockList">
<li class="blockList"><a name="nested.classes.inherited.from.class.javax.swing.JPanel">
<!--   -->
</a>
<h3>Nested classes/interfaces inherited from class&nbsp;javax.swing.JPanel</h3>
<code>javax.swing.JPanel.AccessibleJPanel</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="nested.classes.inherited.from.class.javax.swing.JComponent">
<!--   -->
</a>
<h3>Nested classes/interfaces inherited from class&nbsp;javax.swing.JComponent</h3>
<code>javax.swing.JComponent.AccessibleJComponent</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="nested.classes.inherited.from.class.java.awt.Container">
<!--   -->
</a>
<h3>Nested classes/interfaces inherited from class&nbsp;java.awt.Container</h3>
<code>java.awt.Container.AccessibleAWTContainer</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="nested.classes.inherited.from.class.java.awt.Component">
<!--   -->
</a>
<h3>Nested classes/interfaces inherited from class&nbsp;java.awt.Component</h3>
<code>java.awt.Component.AccessibleAWTComponent, java.awt.Component.BaselineResizeBehavior, java.awt.Component.BltBufferStrategy, java.awt.Component.FlipBufferStrategy</code></li>
</ul>
</li>
</ul>
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#column">column</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#is_playing">is_playing</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#line">line</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#score">score</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#size_pixel">size_pixel</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>(package private) <a href="../main/Cell.html" title="class in main">Cell</a>[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#tab">tab</a></span></code>&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="fields.inherited.from.class.javax.swing.JComponent">
<!--   -->
</a>
<h3>Fields inherited from class&nbsp;javax.swing.JComponent</h3>
<code>listenerList, TOOL_TIP_TEXT_KEY, ui, UNDEFINED_CONDITION, WHEN_ANCESTOR_OF_FOCUSED_COMPONENT, WHEN_FOCUSED, WHEN_IN_FOCUSED_WINDOW</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="fields.inherited.from.class.java.awt.Component">
<!--   -->
</a>
<h3>Fields inherited from class&nbsp;java.awt.Component</h3>
<code>accessibleContext, BOTTOM_ALIGNMENT, CENTER_ALIGNMENT, LEFT_ALIGNMENT, RIGHT_ALIGNMENT, TOP_ALIGNMENT</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="fields.inherited.from.class.java.awt.image.ImageObserver">
<!--   -->
</a>
<h3>Fields inherited from interface&nbsp;java.awt.image.ImageObserver</h3>
<code>ABORT, ALLBITS, ERROR, FRAMEBITS, HEIGHT, PROPERTIES, SOMEBITS, WIDTH</code></li>
</ul>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../main/Grid.html#Grid-int-int-int-">Grid</a></span>(int&nbsp;line,
    int&nbsp;column,
    int&nbsp;size_pixel)</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#action_possible_bis--">action_possible_bis</a></span>()</code>
<div class="block">Méthode permettant de savoir si une action est possible quelque soit la
 direction, c'est à dire que l'on peut réaliser un mouvement OU une fusion</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#action_possible_bis-main.Direction-">action_possible_bis</a></span>(<a href="../main/Direction.html" title="enum in main">Direction</a>&nbsp;direction)</code>
<div class="block">Méthode permettant de savoir si une action est possible avec une
 direction donné, c'est à dire que l'on peut réaliser un mouvement OU une
 fusion dans cette direction</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#apply_physic_to_all_cell-main.Direction-">apply_physic_to_all_cell</a></span>(<a href="../main/Direction.html" title="enum in main">Direction</a>&nbsp;dir)</code>
<div class="block">Méthode permettant d'appliquer les méthode de physique la grille selon
 une direction donnée</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#apply_physic_to_cell_down-int-int-">apply_physic_to_cell_down</a></span>(int&nbsp;i,
                         int&nbsp;j)</code>
<div class="block">Méthode permettant d'appliquer la physique sur une cellule donnée vers le
 bas</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#apply_physic_to_cell_left-int-int-">apply_physic_to_cell_left</a></span>(int&nbsp;i,
                         int&nbsp;j)</code>
<div class="block">Méthode permettant d'appliquer la physique sur une cellule donnée vers la
 gauche</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#apply_physic_to_cell_right-int-int-">apply_physic_to_cell_right</a></span>(int&nbsp;i,
                          int&nbsp;j)</code>
<div class="block">Méthode permettant d'appliquer la physique sur une cellule donnée vers la
 droite</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#apply_physic_to_cell_top-int-int-">apply_physic_to_cell_top</a></span>(int&nbsp;i,
                        int&nbsp;j)</code>
<div class="block">Méthode permettant d'appliquer la physique sur une cellule donnée vers le
 haut</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#can_merge-int-int-int-int-">can_merge</a></span>(int&nbsp;i1,
         int&nbsp;j1,
         int&nbsp;i2,
         int&nbsp;j2)</code>
<div class="block">Méthode permettant de savoir si une fusion est possible entre deux
 cellules, ie : si les deux cellules ont la meme valeur</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#can_play--">can_play</a></span>()</code>
<div class="block">Méthode permettant de savoir si il est possible de jouer dans la grille,
 c'est à dire qu'il reste des actions possibles en tant que mouvement ou
 de fusion</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#create_UI--">create_UI</a></span>()</code>
<div class="block">Methode permettant de créer l'interface graphique de la grille,
 construction des bordures et initialisation des bordures</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#display--">display</a></span>()</code>
<div class="block">Méthode d'affichage console pour réaliser les vérifications pendant le
 développement</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#draw_cell--">draw_cell</a></span>()</code>
<div class="block">Méthode permettant de dessiner les cellules, elle va en réaliser
 actualiser les JLabel de la fenetre avec les bonnes valeurs, les bonnes
 couleurs et les bonnes positions</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#first_and_snd_neighbor--">first_and_snd_neighbor</a></span>()</code>
<div class="block">Méthode permettant de savoir si la case la plus haute en valeur est à
 coté de la deuxième la plus haute en valeur</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#generate_cell_at-int-int-boolean-">generate_cell_at</a></span>(int&nbsp;i,
                int&nbsp;j,
                boolean&nbsp;IA_generation)</code>
<div class="block">Méthode permettant de générer une cellule dans la grille a une position
 donnée</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#generate_cell-boolean-">generate_cell</a></span>(boolean&nbsp;IA_generation)</code>
<div class="block">Méthode permettant de générer une cellule dans la grille de manière
 aléatoire selon les positions restantes</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>java.util.Vector&lt;java.awt.Dimension&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#get_all_free_position--">get_all_free_position</a></span>()</code>
<div class="block">Methode retournant toutes les positions libres dans la grille sous forme
 d'un vector de Dimension</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>private java.awt.Color</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#get_color-int-">get_color</a></span>(int&nbsp;value)</code>
<div class="block">Méthode permettant de récuperer une couleur prédéfinie en fonction de la
 valeur d'une cellule</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#get_column--">get_column</a></span>()</code>
<div class="block">Méthode permettant de récupérer le nombre de colonne dans la grille</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code><a href="../main/Grid.html" title="class in main">Grid</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#get_copy--">get_copy</a></span>()</code>
<div class="block">Méthode permettant de récuperer une copie conforme de la grille actuelle</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>java.awt.Dimension</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#get_highest_tile_position--">get_highest_tile_position</a></span>()</code>
<div class="block">Méthode permettant de récuperer la positon de la cellule avec la plus
 grand valeur dans la grille</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#get_highest_tile--">get_highest_tile</a></span>()</code>
<div class="block">Méthode permettant de récuperer la cellule avec la plus grand valeur dans
 la grille</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#get_line--">get_line</a></span>()</code>
<div class="block">Méthode permettant de récuperer le nombre de ligne dans la grille</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#get_merge_indication--">get_merge_indication</a></span>()</code>
<div class="block">Méthode permettant de récuperer une valuation de merge, c'est à dire que
 l'on regarde pour chaque cellule si on voit un merge possible pour le
 coup suivant, si oui, on ajoute cette valeur de merge à une variable à
 retourner</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#get_nb_free_position--">get_nb_free_position</a></span>()</code>
<div class="block">Méthode permettant de retourner le nombre de position libre</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>java.awt.Dimension</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#get_second_highest_tile_position--">get_second_highest_tile_position</a></span>()</code>
<div class="block">Méthode permettant de récuperer la deuxieme positon de la cellule avec la
 plus grand valeur dans la grille</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#get_second_highest_tile--">get_second_highest_tile</a></span>()</code>
<div class="block">Méthode permettant de récuperer la deuxieme cellule avec la plus grand
 valeur dans la grille</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#get_valuation-main.Direction-main.Direction-main.Direction-">get_valuation</a></span>(<a href="../main/Direction.html" title="enum in main">Direction</a>&nbsp;chosen,
             <a href="../main/Direction.html" title="enum in main">Direction</a>&nbsp;first,
             <a href="../main/Direction.html" title="enum in main">Direction</a>&nbsp;second)</code>
<div class="block">Méthode permettant de récupérer une valuation de la grille en fonction de
 plusieurs critères avec par exemple la cellule avec la plus haute valeur,
 le nombre de cellules libres, etc...</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#getScore--">getScore</a></span>()</code>
<div class="block">Méthode permettant de récuperer le score actuelle qui se trouve dans la
 grille</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#is_highest_at_corner--">is_highest_at_corner</a></span>()</code>
<div class="block">Méthode permettant de savoir si la cellule avec le score le plus elevé se
 trouve dans un des langues de la grille</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#isPlaying--">isPlaying</a></span>()</code>
<div class="block">Méthode permettant de savoir si l'action de jouer est possible c'est à
 dire que l'ia ou que le joueur sont en train de jouer</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#merge_possible_bis--">merge_possible_bis</a></span>()</code>
<div class="block">Méthode permettant de savoir si une fusion est possible dans la grille
 quelque soit la direction</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#merge_possible_bis-main.Direction-">merge_possible_bis</a></span>(<a href="../main/Direction.html" title="enum in main">Direction</a>&nbsp;direction)</code>
<div class="block">Méthode permettant de savoir si une fusion est possible dans la grille
 avec une direction donnée</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#merge_possible_on_cell_direction-int-int-main.Direction-">merge_possible_on_cell_direction</a></span>(int&nbsp;i,
                                int&nbsp;j,
                                <a href="../main/Direction.html" title="enum in main">Direction</a>&nbsp;direction)</code>
<div class="block">Méthode permettant de savoir si une fusion est possible à une cellule
 donnée avec une direction donnée</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#merge_possible_on_cell_down-int-int-">merge_possible_on_cell_down</a></span>(int&nbsp;i,
                           int&nbsp;j)</code>
<div class="block">Méthode permettant de savoir si une fusion est possible à une cellule
 donnée vers le bas</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#merge_possible_on_cell_left-int-int-">merge_possible_on_cell_left</a></span>(int&nbsp;i,
                           int&nbsp;j)</code>
<div class="block">Méthode permettant de savoir si une fusion est possible à une cellule
 donnée vers la gauche</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#merge_possible_on_cell_right-int-int-">merge_possible_on_cell_right</a></span>(int&nbsp;i,
                            int&nbsp;j)</code>
<div class="block">Méthode permettant de savoir si une fusion est possible à une cellule
 donnée vers la droite</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#merge_possible_on_cell_up-int-int-">merge_possible_on_cell_up</a></span>(int&nbsp;i,
                         int&nbsp;j)</code>
<div class="block">Méthode permettant de savoir si une fusion est possible à une cellule
 donnée vers le haut</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#merge_possible_on_cell-int-int-">merge_possible_on_cell</a></span>(int&nbsp;i,
                      int&nbsp;j)</code>
<div class="block">Méthode permettant de savoir si une fusion est possible à une cellule
 donnée quelque soit la direction</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#monotonic_down_left--">monotonic_down_left</a></span>()</code>
<div class="block">Méthode pas termine pour tester la monoticité à partir de la plus grand
 valeur</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#monotonic_down_right--">monotonic_down_right</a></span>()</code>
<div class="block">Méthode pas termine pour tester la monoticité à partir de la plus grand
 valeur</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#monotonic_top_left--">monotonic_top_left</a></span>()</code>
<div class="block">Méthode pas termine pour tester la monoticité à partir de la plus grand
 valeur</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#monotonic_top_right--">monotonic_top_right</a></span>()</code>
<div class="block">Méthode pas termine pour tester la monoticité à partir de la plus grand
 valeur</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#monotonic--">monotonic</a></span>()</code>
<div class="block">Méthode pas termine pour tester la monoticité à partir de la plus grand
 valeur</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#move_possible_bis--">move_possible_bis</a></span>()</code>
<div class="block">Méthode permettant de savoir si un mouvement est possible quelque soit la
 direction</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#move_possible_bis-main.Direction-">move_possible_bis</a></span>(<a href="../main/Direction.html" title="enum in main">Direction</a>&nbsp;direction)</code>
<div class="block">Méthode permettant de savoir si un mouvement est possible avec une
 direction donnée</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#move_possible_on_cell_down-int-int-">move_possible_on_cell_down</a></span>(int&nbsp;i,
                          int&nbsp;j)</code>
<div class="block">Méthode permettant de savoir si un mouvement est possible avec une
 cellule données vers le bas</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#move_possible_on_cell_left-int-int-">move_possible_on_cell_left</a></span>(int&nbsp;i,
                          int&nbsp;j)</code>
<div class="block">Méthode permettant de savoir si un mouvement est possible avec une
 cellule données vers la gauche</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#move_possible_on_cell_right-int-int-">move_possible_on_cell_right</a></span>(int&nbsp;i,
                           int&nbsp;j)</code>
<div class="block">Méthode permettant de savoir si un mouvement est possible avec une
 cellule données vers la droite</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#move_possible_on_cell_top-int-int-">move_possible_on_cell_top</a></span>(int&nbsp;i,
                         int&nbsp;j)</code>
<div class="block">Méthode permettant de savoir si un mouvement est possible avec une
 cellule données vers le haut</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#move_possible_on_cell-int-int-">move_possible_on_cell</a></span>(int&nbsp;i,
                     int&nbsp;j)</code>
<div class="block">Méthode permetttant de savoir si un mouvement est possible avec une
 cellule donnée</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#move_to_direction-main.Direction-boolean-">move_to_direction</a></span>(<a href="../main/Direction.html" title="enum in main">Direction</a>&nbsp;direction,
                 boolean&nbsp;IA_move)</code>
<div class="block">Méthode permettant de réaliser un mouvement de grille avec une direction
 donné.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#paintComponent-java.awt.Graphics-">paintComponent</a></span>(java.awt.Graphics&nbsp;g2)</code>&nbsp;</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#physic_to_direction-main.Direction-">physic_to_direction</a></span>(<a href="../main/Direction.html" title="enum in main">Direction</a>&nbsp;dir)</code>
<div class="block">Méthode permettant d'appliquer la physique à toute les cellules avec une
 direction donnée</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#reinit--">reinit</a></span>()</code>
<div class="block">Methode permettant de réinitialiser la grille de manière, c'est à dire
 que l'on vide toutes les cases du plateau et on remet tous les label à un
 état neutre</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../main/Grid.html#setIsPlaying-boolean-">setIsPlaying</a></span>(boolean&nbsp;b)</code>
<div class="block">Méthode permettant de mettre la valeur de is_playing dans la grille</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.javax.swing.JPanel">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;javax.swing.JPanel</h3>
<code>getAccessibleContext, getUI, getUIClassID, paramString, setUI, updateUI</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.javax.swing.JComponent">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;javax.swing.JComponent</h3>
<code>addAncestorListener, addNotify, addVetoableChangeListener, computeVisibleRect, contains, createToolTip, disable, enable, firePropertyChange, firePropertyChange, firePropertyChange, fireVetoableChange, getActionForKeyStroke, getActionMap, getAlignmentX, getAlignmentY, getAncestorListeners, getAutoscrolls, getBaseline, getBaselineResizeBehavior, getBorder, getBounds, getClientProperty, getComponentGraphics, getComponentPopupMenu, getConditionForKeyStroke, getDebugGraphicsOptions, getDefaultLocale, getFontMetrics, getGraphics, getHeight, getInheritsPopupMenu, getInputMap, getInputMap, getInputVerifier, getInsets, getInsets, getListeners, getLocation, getMaximumSize, getMinimumSize, getNextFocusableComponent, getPopupLocation, getPreferredSize, getRegisteredKeyStrokes, getRootPane, getSize, getToolTipLocation, getToolTipText, getToolTipText, getTopLevelAncestor, getTransferHandler, getVerifyInputWhenFocusTarget, getVetoableChangeListeners, getVisibleRect, getWidth, getX, getY, grabFocus, hide, isDoubleBuffered, isLightweightComponent, isManagingFocus, isOpaque, isOptimizedDrawingEnabled, isPaintingForPrint, isPaintingOrigin, isPaintingTile, isRequestFocusEnabled, isValidateRoot, paint, paintBorder, paintChildren, paintImmediately, paintImmediately, print, printAll, printBorder, printChildren, printComponent, processComponentKeyEvent, processKeyBinding, processKeyEvent, processMouseEvent, processMouseMotionEvent, putClientProperty, registerKeyboardAction, registerKeyboardAction, removeAncestorListener, removeNotify, removeVetoableChangeListener, repaint, repaint, requestDefaultFocus, requestFocus, requestFocus, requestFocusInWindow, requestFocusInWindow, resetKeyboardActions, reshape, revalidate, scrollRectToVisible, setActionMap, setAlignmentX, setAlignmentY, setAutoscrolls, setBackground, setBorder, setComponentPopupMenu, setDebugGraphicsOptions, setDefaultLocale, setDoubleBuffered, setEnabled, setFocusTraversalKeys, setFont, setForeground, setInheritsPopupMenu, setInputMap, setInputVerifier, setMaximumSize, setMinimumSize, setNextFocusableComponent, setOpaque, setPreferredSize, setRequestFocusEnabled, setToolTipText, setTransferHandler, setUI, setVerifyInputWhenFocusTarget, setVisible, unregisterKeyboardAction, update</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.awt.Container">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.awt.Container</h3>
<code>add, add, add, add, add, addContainerListener, addImpl, addPropertyChangeListener, addPropertyChangeListener, applyComponentOrientation, areFocusTraversalKeysSet, countComponents, deliverEvent, doLayout, findComponentAt, findComponentAt, getComponent, getComponentAt, getComponentAt, getComponentCount, getComponents, getComponentZOrder, getContainerListeners, getFocusTraversalKeys, getFocusTraversalPolicy, getLayout, getMousePosition, insets, invalidate, isAncestorOf, isFocusCycleRoot, isFocusCycleRoot, isFocusTraversalPolicyProvider, isFocusTraversalPolicySet, layout, list, list, locate, minimumSize, paintComponents, preferredSize, printComponents, processContainerEvent, processEvent, remove, remove, removeAll, removeContainerListener, setComponentZOrder, setFocusCycleRoot, setFocusTraversalPolicy, setFocusTraversalPolicyProvider, setLayout, transferFocusDownCycle, validate, validateTree</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.awt.Component">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.awt.Component</h3>
<code>action, add, addComponentListener, addFocusListener, addHierarchyBoundsListener, addHierarchyListener, addInputMethodListener, addKeyListener, addMouseListener, addMouseMotionListener, addMouseWheelListener, bounds, checkImage, checkImage, coalesceEvents, contains, createImage, createImage, createVolatileImage, createVolatileImage, disableEvents, dispatchEvent, enable, enableEvents, enableInputMethods, firePropertyChange, firePropertyChange, firePropertyChange, firePropertyChange, firePropertyChange, firePropertyChange, getBackground, getBounds, getColorModel, getComponentListeners, getComponentOrientation, getCursor, getDropTarget, getFocusCycleRootAncestor, getFocusListeners, getFocusTraversalKeysEnabled, getFont, getForeground, getGraphicsConfiguration, getHierarchyBoundsListeners, getHierarchyListeners, getIgnoreRepaint, getInputContext, getInputMethodListeners, getInputMethodRequests, getKeyListeners, getLocale, getLocation, getLocationOnScreen, getMouseListeners, getMouseMotionListeners, getMousePosition, getMouseWheelListeners, getName, getParent, getPeer, getPropertyChangeListeners, getPropertyChangeListeners, getSize, getToolkit, getTreeLock, gotFocus, handleEvent, hasFocus, imageUpdate, inside, isBackgroundSet, isCursorSet, isDisplayable, isEnabled, isFocusable, isFocusOwner, isFocusTraversable, isFontSet, isForegroundSet, isLightweight, isMaximumSizeSet, isMinimumSizeSet, isPreferredSizeSet, isShowing, isValid, isVisible, keyDown, keyUp, list, list, list, location, lostFocus, mouseDown, mouseDrag, mouseEnter, mouseExit, mouseMove, mouseUp, move, nextFocus, paintAll, postEvent, prepareImage, prepareImage, processComponentEvent, processFocusEvent, processHierarchyBoundsEvent, processHierarchyEvent, processInputMethodEvent, processMouseWheelEvent, remove, removeComponentListener, removeFocusListener, removeHierarchyBoundsListener, removeHierarchyListener, removeInputMethodListener, removeKeyListener, removeMouseListener, removeMouseMotionListener, removeMouseWheelListener, removePropertyChangeListener, removePropertyChangeListener, repaint, repaint, repaint, resize, resize, setBounds, setBounds, setComponentOrientation, setCursor, setDropTarget, setFocusable, setFocusTraversalKeysEnabled, setIgnoreRepaint, setLocale, setLocation, setLocation, setName, setSize, setSize, show, show, size, toString, transferFocus, transferFocusBackward, transferFocusUpCycle</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="line">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>line</h4>
<pre>private&nbsp;int line</pre>
</li>
</ul>
<a name="column">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>column</h4>
<pre>private&nbsp;int column</pre>
</li>
</ul>
<a name="size_pixel">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>size_pixel</h4>
<pre>private&nbsp;int size_pixel</pre>
</li>
</ul>
<a name="score">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>score</h4>
<pre>private&nbsp;long score</pre>
</li>
</ul>
<a name="tab">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>tab</h4>
<pre><a href="../main/Cell.html" title="class in main">Cell</a>[][] tab</pre>
</li>
</ul>
<a name="is_playing">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>is_playing</h4>
<pre>private&nbsp;boolean is_playing</pre>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Grid-int-int-int-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Grid</h4>
<pre>public&nbsp;Grid(int&nbsp;line,
            int&nbsp;column,
            int&nbsp;size_pixel)</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="create_UI--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>create_UI</h4>
<pre>public&nbsp;void&nbsp;create_UI()</pre>
<div class="block">Methode permettant de créer l'interface graphique de la grille,
 construction des bordures et initialisation des bordures</div>
</li>
</ul>
<a name="reinit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reinit</h4>
<pre>public&nbsp;void&nbsp;reinit()</pre>
<div class="block">Methode permettant de réinitialiser la grille de manière, c'est à dire
 que l'on vide toutes les cases du plateau et on remet tous les label à un
 état neutre</div>
</li>
</ul>
<a name="get_valuation-main.Direction-main.Direction-main.Direction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>get_valuation</h4>
<pre>public&nbsp;long&nbsp;get_valuation(<a href="../main/Direction.html" title="enum in main">Direction</a>&nbsp;chosen,
                          <a href="../main/Direction.html" title="enum in main">Direction</a>&nbsp;first,
                          <a href="../main/Direction.html" title="enum in main">Direction</a>&nbsp;second)</pre>
<div class="block">Méthode permettant de récupérer une valuation de la grille en fonction de
 plusieurs critères avec par exemple la cellule avec la plus haute valeur,
 le nombre de cellules libres, etc...</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>chosen</code> - La direction choisis pour le déplacement</dd>
<dd><code>first</code> - La direction a privilégier en premier pour une valuation plus
            forte</dd>
<dd><code>second</code> - La direction à privilégier en deuxième pour une valuation plus
            forte</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne la valuation sous la forme d'un long</dd>
</dl>
</li>
</ul>
<a name="monotonic--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>monotonic</h4>
<pre>public&nbsp;int&nbsp;monotonic()</pre>
<div class="block">Méthode pas termine pour tester la monoticité à partir de la plus grand
 valeur</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne la valeur de la monoticité</dd>
</dl>
</li>
</ul>
<a name="monotonic_top_right--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>monotonic_top_right</h4>
<pre>public&nbsp;int&nbsp;monotonic_top_right()</pre>
<div class="block">Méthode pas termine pour tester la monoticité à partir de la plus grand
 valeur</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>l'étape de monoticité</dd>
</dl>
</li>
</ul>
<a name="monotonic_top_left--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>monotonic_top_left</h4>
<pre>public&nbsp;int&nbsp;monotonic_top_left()</pre>
<div class="block">Méthode pas termine pour tester la monoticité à partir de la plus grand
 valeur</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>l'étape de monoticité</dd>
</dl>
</li>
</ul>
<a name="monotonic_down_right--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>monotonic_down_right</h4>
<pre>public&nbsp;int&nbsp;monotonic_down_right()</pre>
<div class="block">Méthode pas termine pour tester la monoticité à partir de la plus grand
 valeur</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>l'étape de monoticité</dd>
</dl>
</li>
</ul>
<a name="monotonic_down_left--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>monotonic_down_left</h4>
<pre>public&nbsp;int&nbsp;monotonic_down_left()</pre>
<div class="block">Méthode pas termine pour tester la monoticité à partir de la plus grand
 valeur</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>l'étape de monoticité</dd>
</dl>
</li>
</ul>
<a name="is_highest_at_corner--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>is_highest_at_corner</h4>
<pre>public&nbsp;boolean&nbsp;is_highest_at_corner()</pre>
<div class="block">Méthode permettant de savoir si la cellule avec le score le plus elevé se
 trouve dans un des langues de la grille</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vrai si la cellule est dans un angle, faux sinon</dd>
</dl>
</li>
</ul>
<a name="get_all_free_position--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>get_all_free_position</h4>
<pre>public&nbsp;java.util.Vector&lt;java.awt.Dimension&gt;&nbsp;get_all_free_position()</pre>
<div class="block">Methode retournant toutes les positions libres dans la grille sous forme
 d'un vector de Dimension</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Retourne toutes les positions libres</dd>
</dl>
</li>
</ul>
<a name="get_merge_indication--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>get_merge_indication</h4>
<pre>public&nbsp;long&nbsp;get_merge_indication()</pre>
<div class="block">Méthode permettant de récuperer une valuation de merge, c'est à dire que
 l'on regarde pour chaque cellule si on voit un merge possible pour le
 coup suivant, si oui, on ajoute cette valeur de merge à une variable à
 retourner</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne le valeur de merge maximum</dd>
</dl>
</li>
</ul>
<a name="get_nb_free_position--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>get_nb_free_position</h4>
<pre>public&nbsp;int&nbsp;get_nb_free_position()</pre>
<div class="block">Méthode permettant de retourner le nombre de position libre</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>le nomre de position libre</dd>
</dl>
</li>
</ul>
<a name="get_line--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>get_line</h4>
<pre>public&nbsp;int&nbsp;get_line()</pre>
<div class="block">Méthode permettant de récuperer le nombre de ligne dans la grille</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>le nombre de ligne dans la grille</dd>
</dl>
</li>
</ul>
<a name="get_column--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>get_column</h4>
<pre>public&nbsp;int&nbsp;get_column()</pre>
<div class="block">Méthode permettant de récupérer le nombre de colonne dans la grille</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>le nombre de colonne dans la grille</dd>
</dl>
</li>
</ul>
<a name="getScore--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getScore</h4>
<pre>public&nbsp;long&nbsp;getScore()</pre>
<div class="block">Méthode permettant de récuperer le score actuelle qui se trouve dans la
 grille</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>le score dans la grille</dd>
</dl>
</li>
</ul>
<a name="isPlaying--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isPlaying</h4>
<pre>public&nbsp;boolean&nbsp;isPlaying()</pre>
<div class="block">Méthode permettant de savoir si l'action de jouer est possible c'est à
 dire que l'ia ou que le joueur sont en train de jouer</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vrai si le jeu est en train de se jouer, faux sinon</dd>
</dl>
</li>
</ul>
<a name="setIsPlaying-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setIsPlaying</h4>
<pre>public&nbsp;void&nbsp;setIsPlaying(boolean&nbsp;b)</pre>
<div class="block">Méthode permettant de mettre la valeur de is_playing dans la grille</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>b</code> - la valeur de is_playing que l'on souhaite assigner</dd>
</dl>
</li>
</ul>
<a name="can_play--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>can_play</h4>
<pre>public&nbsp;boolean&nbsp;can_play()</pre>
<div class="block">Méthode permettant de savoir si il est possible de jouer dans la grille,
 c'est à dire qu'il reste des actions possibles en tant que mouvement ou
 de fusion</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne vrai si on peut encore jouer, faux sinon</dd>
</dl>
</li>
</ul>
<a name="get_copy--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>get_copy</h4>
<pre>public&nbsp;<a href="../main/Grid.html" title="class in main">Grid</a>&nbsp;get_copy()</pre>
<div class="block">Méthode permettant de récuperer une copie conforme de la grille actuelle</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne une grille qui est une copie distincte de la grille
         actuelle</dd>
</dl>
</li>
</ul>
<a name="first_and_snd_neighbor--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>first_and_snd_neighbor</h4>
<pre>public&nbsp;boolean&nbsp;first_and_snd_neighbor()</pre>
<div class="block">Méthode permettant de savoir si la case la plus haute en valeur est à
 coté de la deuxième la plus haute en valeur</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne vrai si les deux cases sont cote à cote, faux sinon</dd>
</dl>
</li>
</ul>
<a name="get_highest_tile--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>get_highest_tile</h4>
<pre>public&nbsp;int&nbsp;get_highest_tile()</pre>
<div class="block">Méthode permettant de récuperer la cellule avec la plus grand valeur dans
 la grille</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne la plus grande valeur dans la grille</dd>
</dl>
</li>
</ul>
<a name="get_highest_tile_position--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>get_highest_tile_position</h4>
<pre>public&nbsp;java.awt.Dimension&nbsp;get_highest_tile_position()</pre>
<div class="block">Méthode permettant de récuperer la positon de la cellule avec la plus
 grand valeur dans la grille</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne la position de la cellule avec la plus grande valeur
         sous forme d'une variable Dimension</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>Dimension</code></dd>
</dl>
</li>
</ul>
<a name="get_second_highest_tile--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>get_second_highest_tile</h4>
<pre>public&nbsp;int&nbsp;get_second_highest_tile()</pre>
<div class="block">Méthode permettant de récuperer la deuxieme cellule avec la plus grand
 valeur dans la grille</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne la deuximeple plus grande valeur dans la grille</dd>
</dl>
</li>
</ul>
<a name="get_second_highest_tile_position--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>get_second_highest_tile_position</h4>
<pre>public&nbsp;java.awt.Dimension&nbsp;get_second_highest_tile_position()</pre>
<div class="block">Méthode permettant de récuperer la deuxieme positon de la cellule avec la
 plus grand valeur dans la grille</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne la position de la deuxieme cellule avec la plus grande
         valeur sous forme d'une variable Dimension</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>Dimension</code></dd>
</dl>
</li>
</ul>
<a name="action_possible_bis--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>action_possible_bis</h4>
<pre>public&nbsp;boolean&nbsp;action_possible_bis()</pre>
<div class="block">Méthode permettant de savoir si une action est possible quelque soit la
 direction, c'est à dire que l'on peut réaliser un mouvement OU une fusion</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vrai si action possible, faux sinon</dd>
</dl>
</li>
</ul>
<a name="action_possible_bis-main.Direction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>action_possible_bis</h4>
<pre>public&nbsp;boolean&nbsp;action_possible_bis(<a href="../main/Direction.html" title="enum in main">Direction</a>&nbsp;direction)</pre>
<div class="block">Méthode permettant de savoir si une action est possible avec une
 direction donné, c'est à dire que l'on peut réaliser un mouvement OU une
 fusion dans cette direction</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>direction</code> - la direction avec laquelle on veut savoir si on peut réaliser
            une action</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vrai si l'action est possible, faux sinon</dd>
</dl>
</li>
</ul>
<a name="move_to_direction-main.Direction-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>move_to_direction</h4>
<pre>public&nbsp;void&nbsp;move_to_direction(<a href="../main/Direction.html" title="enum in main">Direction</a>&nbsp;direction,
                              boolean&nbsp;IA_move)</pre>
<div class="block">Méthode permettant de réaliser un mouvement de grille avec une direction
 donné. Si c'est un mouvement IA, alors on ne redessine pas les cellules
 car c'est un mouvement interne pour simuler</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>direction</code> - la direction que l'on souhaite pour le mouvement</dd>
<dd><code>IA_move</code> - savoir si le mouvement demandé est réalisé par l'utilisateur
            ou par l'IA</dd>
</dl>
</li>
</ul>
<a name="move_possible_bis--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>move_possible_bis</h4>
<pre>public&nbsp;boolean&nbsp;move_possible_bis()</pre>
<div class="block">Méthode permettant de savoir si un mouvement est possible quelque soit la
 direction</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne vrai si un mouvement est possible, faux sinon</dd>
</dl>
</li>
</ul>
<a name="move_possible_bis-main.Direction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>move_possible_bis</h4>
<pre>public&nbsp;boolean&nbsp;move_possible_bis(<a href="../main/Direction.html" title="enum in main">Direction</a>&nbsp;direction)</pre>
<div class="block">Méthode permettant de savoir si un mouvement est possible avec une
 direction donnée</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>direction</code> - la direction que l'on souhaite tester</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne vrai si un mouvement est possible, faux sinon</dd>
</dl>
</li>
</ul>
<a name="move_possible_on_cell-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>move_possible_on_cell</h4>
<pre>public&nbsp;boolean&nbsp;move_possible_on_cell(int&nbsp;i,
                                     int&nbsp;j)</pre>
<div class="block">Méthode permetttant de savoir si un mouvement est possible avec une
 cellule donnée</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - l'index X de la cellule que l'on souhaite tester</dd>
<dd><code>j</code> - l'index Y de la cellule que l'on souhaite tester</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne vrai si le mouvement sur la cellule est possible, faux
         sinon</dd>
</dl>
</li>
</ul>
<a name="move_possible_on_cell_top-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>move_possible_on_cell_top</h4>
<pre>public&nbsp;boolean&nbsp;move_possible_on_cell_top(int&nbsp;i,
                                         int&nbsp;j)</pre>
<div class="block">Méthode permettant de savoir si un mouvement est possible avec une
 cellule données vers le haut</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - l'index X de la cellule que l'on souhaite tester</dd>
<dd><code>j</code> - l'index Y de la cellule que l'on souhaite tester</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne vrai si on peut bouger la cellule vers le haut, faux
         sinon</dd>
</dl>
</li>
</ul>
<a name="move_possible_on_cell_down-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>move_possible_on_cell_down</h4>
<pre>public&nbsp;boolean&nbsp;move_possible_on_cell_down(int&nbsp;i,
                                          int&nbsp;j)</pre>
<div class="block">Méthode permettant de savoir si un mouvement est possible avec une
 cellule données vers le bas</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - l'index X de la cellule que l'on souhaite tester</dd>
<dd><code>j</code> - l'index Y de la cellule que l'on souhaite tester</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne vrai si on peut bouger la cellule vers le haut, faux
         sinon</dd>
</dl>
</li>
</ul>
<a name="move_possible_on_cell_left-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>move_possible_on_cell_left</h4>
<pre>public&nbsp;boolean&nbsp;move_possible_on_cell_left(int&nbsp;i,
                                          int&nbsp;j)</pre>
<div class="block">Méthode permettant de savoir si un mouvement est possible avec une
 cellule données vers la gauche</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - l'index X de la cellule que l'on souhaite tester</dd>
<dd><code>j</code> - l'index Y de la cellule que l'on souhaite tester</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne vrai si on peut bouger la cellule vers le haut, faux
         sinon</dd>
</dl>
</li>
</ul>
<a name="move_possible_on_cell_right-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>move_possible_on_cell_right</h4>
<pre>public&nbsp;boolean&nbsp;move_possible_on_cell_right(int&nbsp;i,
                                           int&nbsp;j)</pre>
<div class="block">Méthode permettant de savoir si un mouvement est possible avec une
 cellule données vers la droite</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - l'index X de la cellule que l'on souhaite tester</dd>
<dd><code>j</code> - l'index Y de la cellule que l'on souhaite tester</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne vrai si on peut bouger la cellule vers le haut, faux
         sinon</dd>
</dl>
</li>
</ul>
<a name="merge_possible_bis--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge_possible_bis</h4>
<pre>public&nbsp;boolean&nbsp;merge_possible_bis()</pre>
<div class="block">Méthode permettant de savoir si une fusion est possible dans la grille
 quelque soit la direction</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne vrai si la direction est possible, faux sinon</dd>
</dl>
</li>
</ul>
<a name="merge_possible_bis-main.Direction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge_possible_bis</h4>
<pre>public&nbsp;boolean&nbsp;merge_possible_bis(<a href="../main/Direction.html" title="enum in main">Direction</a>&nbsp;direction)</pre>
<div class="block">Méthode permettant de savoir si une fusion est possible dans la grille
 avec une direction donnée</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>direction</code> - la direction que l'on souhaite tester pour la fusion</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>vrai si la fusion est possible, faux sinon</dd>
</dl>
</li>
</ul>
<a name="merge_possible_on_cell-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge_possible_on_cell</h4>
<pre>public&nbsp;boolean&nbsp;merge_possible_on_cell(int&nbsp;i,
                                      int&nbsp;j)</pre>
<div class="block">Méthode permettant de savoir si une fusion est possible à une cellule
 donnée quelque soit la direction</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - index X de la cellule que l'on souhaite tester</dd>
<dd><code>j</code> - index Y de la cellule que l'on souhaite tester</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne vrai si l'on peut fusionner sur cette cellule, faux
         sinon</dd>
</dl>
</li>
</ul>
<a name="merge_possible_on_cell_direction-int-int-main.Direction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge_possible_on_cell_direction</h4>
<pre>public&nbsp;boolean&nbsp;merge_possible_on_cell_direction(int&nbsp;i,
                                                int&nbsp;j,
                                                <a href="../main/Direction.html" title="enum in main">Direction</a>&nbsp;direction)</pre>
<div class="block">Méthode permettant de savoir si une fusion est possible à une cellule
 donnée avec une direction donnée</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - index X de la cellule que l'on souhaite tester</dd>
<dd><code>j</code> - index Y de la cellule que l'on souhaite tester</dd>
<dd><code>direction</code> - la direction que l'on souhaite tester la fusion</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne vrai si l'on peut fusionner avec cette cellule, faux
         sinon</dd>
</dl>
</li>
</ul>
<a name="merge_possible_on_cell_up-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge_possible_on_cell_up</h4>
<pre>public&nbsp;boolean&nbsp;merge_possible_on_cell_up(int&nbsp;i,
                                         int&nbsp;j)</pre>
<div class="block">Méthode permettant de savoir si une fusion est possible à une cellule
 donnée vers le haut</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - index X de la cellule que l'on souhaite tester</dd>
<dd><code>j</code> - index Y de la cellule que l'on souhaite tester</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>return vrai si la fusion vers le haut est possible, faux sinon</dd>
</dl>
</li>
</ul>
<a name="merge_possible_on_cell_down-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge_possible_on_cell_down</h4>
<pre>public&nbsp;boolean&nbsp;merge_possible_on_cell_down(int&nbsp;i,
                                           int&nbsp;j)</pre>
<div class="block">Méthode permettant de savoir si une fusion est possible à une cellule
 donnée vers le bas</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - index X de la cellule que l'on souhaite tester</dd>
<dd><code>j</code> - index Y de la cellule que l'on souhaite tester</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>return vrai si la fusion vers le bas est possible, faux sinon</dd>
</dl>
</li>
</ul>
<a name="merge_possible_on_cell_left-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge_possible_on_cell_left</h4>
<pre>public&nbsp;boolean&nbsp;merge_possible_on_cell_left(int&nbsp;i,
                                           int&nbsp;j)</pre>
<div class="block">Méthode permettant de savoir si une fusion est possible à une cellule
 donnée vers la gauche</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - index X de la cellule que l'on souhaite tester</dd>
<dd><code>j</code> - index Y de la cellule que l'on souhaite tester</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>return vrai si la fusion vers la gauche est possible, faux sinon</dd>
</dl>
</li>
</ul>
<a name="merge_possible_on_cell_right-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge_possible_on_cell_right</h4>
<pre>public&nbsp;boolean&nbsp;merge_possible_on_cell_right(int&nbsp;i,
                                            int&nbsp;j)</pre>
<div class="block">Méthode permettant de savoir si une fusion est possible à une cellule
 donnée vers la droite</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - index X de la cellule que l'on souhaite tester</dd>
<dd><code>j</code> - index Y de la cellule que l'on souhaite tester</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>return vrai si la fusion vers la droite est possible, faux sinon</dd>
</dl>
</li>
</ul>
<a name="generate_cell-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generate_cell</h4>
<pre>public&nbsp;void&nbsp;generate_cell(boolean&nbsp;IA_generation)</pre>
<div class="block">Méthode permettant de générer une cellule dans la grille de manière
 aléatoire selon les positions restantes</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>IA_generation</code> - boolean permettant de savoir si il faut redesinner les
            cellules ou non</dd>
</dl>
</li>
</ul>
<a name="generate_cell_at-int-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generate_cell_at</h4>
<pre>public&nbsp;void&nbsp;generate_cell_at(int&nbsp;i,
                             int&nbsp;j,
                             boolean&nbsp;IA_generation)</pre>
<div class="block">Méthode permettant de générer une cellule dans la grille a une position
 donnée</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - index X de la cellule ou l'on veut générer la case</dd>
<dd><code>j</code> - index Y de la celulle ou l'on veut générer la case</dd>
<dd><code>IA_generation</code> - boolean permettant de savoir si il faut redesinner les
            cellules ou non</dd>
</dl>
</li>
</ul>
<a name="can_merge-int-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>can_merge</h4>
<pre>public&nbsp;boolean&nbsp;can_merge(int&nbsp;i1,
                         int&nbsp;j1,
                         int&nbsp;i2,
                         int&nbsp;j2)</pre>
<div class="block">Méthode permettant de savoir si une fusion est possible entre deux
 cellules, ie : si les deux cellules ont la meme valeur</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i1</code> - index X de la premiére cellule</dd>
<dd><code>j1</code> - index Y de la premiére cellule</dd>
<dd><code>i2</code> - index X de la deuxième cellule</dd>
<dd><code>j2</code> - index Y de la deuxième cellule</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne vrai si la fusion est possible, faux sinon</dd>
</dl>
</li>
</ul>
<a name="apply_physic_to_all_cell-main.Direction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>apply_physic_to_all_cell</h4>
<pre>public&nbsp;void&nbsp;apply_physic_to_all_cell(<a href="../main/Direction.html" title="enum in main">Direction</a>&nbsp;dir)</pre>
<div class="block">Méthode permettant d'appliquer les méthode de physique la grille selon
 une direction donnée</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dir</code> - la direction vers laquelle on veut appliquer la physique</dd>
</dl>
</li>
</ul>
<a name="apply_physic_to_cell_top-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>apply_physic_to_cell_top</h4>
<pre>public&nbsp;boolean&nbsp;apply_physic_to_cell_top(int&nbsp;i,
                                        int&nbsp;j)</pre>
<div class="block">Méthode permettant d'appliquer la physique sur une cellule donnée vers le
 haut</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - index X de la cellule ou l'on veut appliquer la physique</dd>
<dd><code>j</code> - index Y de la cellule ou l'on veut appliquer la physique</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne vrai si une fusion a été appliqué , faux sinon</dd>
</dl>
</li>
</ul>
<a name="apply_physic_to_cell_down-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>apply_physic_to_cell_down</h4>
<pre>public&nbsp;boolean&nbsp;apply_physic_to_cell_down(int&nbsp;i,
                                         int&nbsp;j)</pre>
<div class="block">Méthode permettant d'appliquer la physique sur une cellule donnée vers le
 bas</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - index X de la cellule ou l'on veut appliquer la physique</dd>
<dd><code>j</code> - index Y de la cellule ou l'on veut appliquer la physique</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne vrai si une fusion a été appliqué , faux sinon</dd>
</dl>
</li>
</ul>
<a name="apply_physic_to_cell_left-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>apply_physic_to_cell_left</h4>
<pre>public&nbsp;boolean&nbsp;apply_physic_to_cell_left(int&nbsp;i,
                                         int&nbsp;j)</pre>
<div class="block">Méthode permettant d'appliquer la physique sur une cellule donnée vers la
 gauche</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - index X de la cellule ou l'on veut appliquer la physique</dd>
<dd><code>j</code> - index Y de la cellule ou l'on veut appliquer la physique</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne vrai si une fusion a été appliqué , faux sinon</dd>
</dl>
</li>
</ul>
<a name="apply_physic_to_cell_right-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>apply_physic_to_cell_right</h4>
<pre>public&nbsp;boolean&nbsp;apply_physic_to_cell_right(int&nbsp;i,
                                          int&nbsp;j)</pre>
<div class="block">Méthode permettant d'appliquer la physique sur une cellule donnée vers la
 droite</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - index X de la cellule ou l'on veut appliquer la physique</dd>
<dd><code>j</code> - index Y de la cellule ou l'on veut appliquer la physique</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne vrai si une fusion a été appliqué , faux sinon</dd>
</dl>
</li>
</ul>
<a name="physic_to_direction-main.Direction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>physic_to_direction</h4>
<pre>public&nbsp;void&nbsp;physic_to_direction(<a href="../main/Direction.html" title="enum in main">Direction</a>&nbsp;dir)</pre>
<div class="block">Méthode permettant d'appliquer la physique à toute les cellules avec une
 direction donnée</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dir</code> - la direction que l'on souhaite utiliser pour la physique</dd>
</dl>
</li>
</ul>
<a name="paintComponent-java.awt.Graphics-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>paintComponent</h4>
<pre>public&nbsp;void&nbsp;paintComponent(java.awt.Graphics&nbsp;g2)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>paintComponent</code>&nbsp;in class&nbsp;<code>javax.swing.JComponent</code></dd>
</dl>
</li>
</ul>
<a name="get_color-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>get_color</h4>
<pre>private&nbsp;java.awt.Color&nbsp;get_color(int&nbsp;value)</pre>
<div class="block">Méthode permettant de récuperer une couleur prédéfinie en fonction de la
 valeur d'une cellule</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - la valeur de la cellule dont l'on veut connaitre la couleur</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>retourne une couleur sous forme de couleur SWING avec une valeur
         RGB</dd>
</dl>
</li>
</ul>
<a name="display--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>display</h4>
<pre>public&nbsp;void&nbsp;display()</pre>
<div class="block">Méthode d'affichage console pour réaliser les vérifications pendant le
 développement</div>
</li>
</ul>
<a name="draw_cell--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>draw_cell</h4>
<pre>public&nbsp;void&nbsp;draw_cell()</pre>
<div class="block">Méthode permettant de dessiner les cellules, elle va en réaliser
 actualiser les JLabel de la fenetre avec les bonnes valeurs, les bonnes
 couleurs et les bonnes positions</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Grid.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../main/Direction.html" title="enum in main"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../main/IA_player.html" title="class in main"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../index.html?main/Grid.html" target="_top">Frames</a></li>
<li><a href="Grid.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.classes.inherited.from.class.javax.swing.JPanel">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
